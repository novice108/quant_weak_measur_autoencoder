# -*- coding: utf-8 -*-
"""ClassicalAutoencoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ha93xHDKth99xGtWOVdaooqPVEZ5fMAL
"""

!pip install numpy matplotlib scikit-learn tensorflow

!pip uninstall -y keras tensorflow-gpu

!pip install tensorflow==2.12.0

!pip show tensorflow
!pip show numpy

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Input
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

# **Генерація синусоїдальних сигналів**
def generate_sine_wave(samples=1000, frequency=5, amplitude=1, phase=0):
    t = np.linspace(0, 2 * np.pi, samples)
    return amplitude * np.sin(frequency * t + phase)

# **Підготовка даних**
def generate_dataset(n_samples=1000, signal_dim=1000):
    signals = []
    for _ in range(n_samples):
        freq = np.random.uniform(1, 10)  # Частота від 1 до 10 Гц
        amp = np.random.uniform(0.5, 1.5)  # Амплітуда від 0.5 до 1.5
        phase = np.random.uniform(0, 2 * np.pi)  # Фаза від 0 до 2π
        signal = generate_sine_wave(samples=signal_dim, frequency=freq, amplitude=amp, phase=phase)
        signals.append(signal)
    return np.array(signals)

# **Параметри**
n_samples = 1000
signal_dim = 1000
latent_dim = 5  # Розмір латентного простору

# Генерація даних
data = generate_dataset(n_samples=n_samples, signal_dim=signal_dim)
X_train, X_test = train_test_split(data, test_size=0.2, random_state=42)

# **Створення автоенкодера**
def build_autoencoder(input_dim, latent_dim):
    model = Sequential([
        Input(shape=(input_dim,)),
        Dense(512, activation='relu'),
        Dense(256, activation='relu'),
        Dense(latent_dim, activation='relu'),  # Латентний простір
        Dense(256, activation='relu'),
        Dense(512, activation='relu'),
        Dense(input_dim, activation='linear')  # Вихідний шар
    ])
    return model

autoencoder = build_autoencoder(input_dim=signal_dim, latent_dim=latent_dim)
autoencoder.compile(optimizer='adam', loss='mse')

# **Навчання**
history = autoencoder.fit(
    X_train, X_train,
    validation_data=(X_test, X_test),
    epochs=1000,
    batch_size=32,
    verbose=1
)

# **Оцінка якості**
reconstructed = autoencoder.predict(X_test)
mse = [mean_squared_error(X_test[i], reconstructed[i]) for i in range(len(X_test))]
r2 = [r2_score(X_test[i], reconstructed[i]) for i in range(len(X_test))]
print(f"Average MSE: {np.mean(mse):.4f}")
print(f"Average R2 Score: {np.mean(r2):.4f}")

# **Візуалізація втрат**
plt.figure(figsize=(8, 5))
plt.plot(history.history['loss'], label='Training Loss', color='blue')
plt.plot(history.history['val_loss'], label='Validation Loss', color='orange')
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
plt.show()

# **Візуалізація сигналів**
plt.figure(figsize=(10, 5))
plt.plot(X_test[0], label='Original Signal', color='green', alpha=0.7)
plt.plot(reconstructed[0], label='Reconstructed Signal', color='blue', linestyle='--')
plt.title('Signal Reconstruction')
plt.legend()
plt.show()

# Візуалізація сигналів
for i in range(100):  # Відобразимо всі 100 сигналів
    plt.figure(figsize=(10, 4))
    plt.plot(X_test[i], label="Original Signal", color="green", alpha=0.7)
    plt.plot(reconstructed[i], label="Reconstructed Signal", color="blue", linestyle='--')
    plt.title(f"Signal {i + 1}")
    plt.legend()
    plt.show()